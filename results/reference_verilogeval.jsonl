{"task_id": "mux2to1v", "completion": "\tassign out = sel ? b : a;\n\nendmodule\n"}
{"task_id": "m2014_q6b", "completion": "\talways @(*) begin\n\t\tcase (y)\n\t\t\t3'b000: Y2 = 1'b0; // State A\n\t\t\t3'b001: Y2 = 1'b0; // State B\n\t\t\t3'b010: Y2 = 1'b0; // State C\n\t\t\t3'b011: Y2 = 1'b1; // State D\n\t\t\t3'b100: Y2 = 1'b1; // State E\n\t\t\t3'b101: Y2 = 1'b1; // State F\n\t\t\tdefault: Y2 = 1'b0;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "ringer", "completion": "\tassign ringer = ring & ~vibrate_mode;\n\tassign motor = vibrate_mode;\n\nendmodule\n"}
{"task_id": "alwaysblock1", "completion": "\t// Using assign statement\n\tassign out_assign = a & b;\n\n\t// Using combinational always block\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\n\nendmodule\n"}
{"task_id": "zero", "completion": "\tassign zero = 1'b0;\n\nendmodule\n"}
{"task_id": "circuit7", "completion": "always @(posedge clk) begin\n\tq <= a;\nend\n\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "completion": "\twire [1:0] state, next_state;\n\treg [1:0] state_reg;\n\n\tassign state = state_reg;\n\n\tlocalparam IDLE = 2'b00;\n\tlocalparam COMPUTE = 2'b01;\n\tlocalparam DONE = 2'b10;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate_reg <= IDLE;\n\t\telse\n\t\t\tstate_reg <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: next_state = x ? COMPUTE : IDLE;\n\t\t\tCOMPUTE: next_state = x ? COMPUTE : DONE;\n\t\t\tDONE: next_state = x ? COMPUTE : IDLE;\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\n\tassign z = (state == DONE) ? ~x : x;\n\nendmodule\n"}
{"task_id": "fsm3", "completion": "\treg [1:0] state, next_state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign out = (state == D);\n\nendmodule\n"}
{"task_id": "vector2", "completion": "\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n"}
{"task_id": "m2014_q4c", "completion": "\talways_ff @(posedge clk) begin\n\t\tif (r)\n\t\t\tq <= 1'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "mt2015_q4a", "completion": "\tz = (x ^ y) & x;\n\nendmodule\n"}
{"task_id": "shift18", "completion": "\treg [63:0] shifter;\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tshifter <= data;\n\t\tend\n\t\telse if (ena) begin\n\t\t\tcase (amount)\n\t\t\t\t2'b00: shifter <= {shifter[62:0], 1'b0}; // Shift left by 1 bit\n\t\t\t\t2'b01: shifter <= {shifter[55:0], 8'b0}; // Shift left by 8 bits\n\t\t\t\t2'b10: shifter <= {1'b0, shifter[63:1]}; // Shift right by 1 bit\n\t\t\t\t2'b11: shifter <= {8'b11111111, shifter[63:8]}; // Shift right by 8 bits\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tq <= shifter;\n\tend\n\nendmodule\n"}
{"task_id": "ece241_2013_q8", "completion": "\treg [1:0] state, next_state;\n\tlocalparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: begin\n\t\t\t\tif (x)\n\t\t\t\t\tnext_state = S1;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tz = 1'b0;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (!x)\n\t\t\t\t\tnext_state = S2;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S1;\n\t\t\t\tz = 1'b0;\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tnext_state = S1;\n\t\t\t\t\tz = 1'b1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tz = 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = S0;\n\t\t\t\tz = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q6", "completion": "\treg [2:0] state;\n\tparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= A;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: state <= w ? A : B;\n\t\t\t\tB: state <= w ? D : C;\n\t\t\t\tC: state <= w ? D : E;\n\t\t\t\tD: state <= w ? A : F;\n\t\t\t\tE: state <= w ? D : E;\n\t\t\t\tF: state <= w ? D : C;\n\t\t\t\tdefault: state <= A;\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign z = (state == E) || (state == F);\n\nendmodule\n"}
{"task_id": "fsm_ps2data", "completion": "\twire [2:0] state;\n\twire [2:0] next_state;\n\treg [23:0] message;\n\treg [1:0] byte_count;\n\n\t// State definitions\n\tlocalparam IDLE = 3'b000;\n\tlocalparam WAIT_FOR_BYTE = 3'b001;\n\tlocalparam RECEIVE_BYTE = 3'b010;\n\tlocalparam MESSAGE_COMPLETE = 3'b011;\n\n\t// State register\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic\n\tassign next_state = (state == IDLE) ? WAIT_FOR_BYTE :\n\t                    (state == WAIT_FOR_BYTE && in[3]) ? RECEIVE_BYTE :\n\t                    (state == RECEIVE_BYTE) ? MESSAGE_COMPLETE :\n\t                    (state == MESSAGE_COMPLETE) ? WAIT_FOR_BYTE :\n\t                    IDLE;\n\n\t// Output logic\n\tassign done = (state == MESSAGE_COMPLETE);\n\n\t// Message register\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tmessage <= 24'b0;\n\t\t\tbyte_count <= 2'b0;\n\t\tend else if (state == RECEIVE_BYTE) begin\n\t\t\tmessage <= {in, message[23:8]};\n\t\t\tbyte_count <= byte_count + 1;\n\t\tend else if (state == MESSAGE_COMPLETE) begin\n\t\t\tbyte_count <= 2'b0;\n\t\tend\n\tend\n\n\t// Output assignment\n\tassign out_bytes = (state == MESSAGE_COMPLETE) ? message : 24'bx;\n\nendmodule\n"}
{"task_id": "2012_q2b", "completion": "\t// Y1 logic\n\tassign Y1 = (y[1] & ~w) | (y[2] & w) | (y[3] & ~w) | (y[4] & w) | (y[5] & ~w);\n\n\t// Y3 logic\n\tassign Y3 = (y[1] & ~w) | (y[2] & w) | (y[3] & ~w) | (y[4] & w) | (y[5] & ~w);\n\nendmodule\n"}
{"task_id": "vector0", "completion": "\tassign outv = vec;\n\tassign o2 = vec[2];\n\tassign o1 = vec[1];\n\tassign o0 = vec[0];\n\nendmodule\n"}
{"task_id": "kmap4", "completion": "always @(*) begin\n\tif (a == 0 && b == 0 && c == 0 && d == 0)\n\t\tout = 0;\n\telse if (a == 0 && b == 0 && c == 1 && d == 0)\n\t\tout = 1;\n\telse if (a == 0 && b == 0 && c == 1 && d == 1)\n\t\tout = 0;\n\telse if (a == 0 && b == 1 && c == 0 && d == 0)\n\t\tout = 1;\n\telse if (a == 0 && b == 1 && c == 0 && d == 1)\n\t\tout = 0;\n\telse if (a == 0 && b == 1 && c == 1 && d == 0)\n\t\tout = 0;\n\telse if (a == 0 && b == 1 && c == 1 && d == 1)\n\t\tout = 1;\n\telse if (a == 1 && b == 0 && c == 0 && d == 0)\n\t\tout = 0;\n\telse if (a == 1 && b == 0 && c == 0 && d == 1)\n\t\tout = 1;\n\telse if (a == 1 && b == 0 && c == 1 && d == 0)\n\t\tout = 1;\n\telse if (a == 1 && b == 0 && c == 1 && d == 1)\n\t\tout = 0;\n\telse if (a == 1 && b == 1 && c == 0 && d == 0)\n\t\tout = 1;\n\telse if (a == 1 && b == 1 && c == 0 && d == 1)\n\t\tout = 0;\n\telse if (a == 1 && b == 1 && c == 1 && d == 0)\n\t\tout = 0;\n\telse if (a == 1 && b == 1 && c == 1 && d == 1)\n\t\tout = 1;\nend\n\nendmodule\n"}
{"task_id": "vector1", "completion": "\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0];\n\nendmodule\n"}
{"task_id": "norgate", "completion": "\twire nor_out;\n\n\tnor(nor_out, a, b);\n\tnot(out, nor_out);\n\nendmodule\n"}
{"task_id": "alwaysblock2", "completion": "\t// XOR gate using assign statement\n\tassign out_assign = a ^ b;\n\n\t// XOR gate using combinational always block\n\talways @(*) begin\n\t\tout_always_comb = a ^ b;\n\tend\n\n\t// XOR gate using clocked always block\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q6c", "completion": "\t// Y2 logic\n\tassign Y2 = (y[2] & ~w) | (y[3] & w) | (y[5] & ~w) | (y[6] & w);\n\n\t// Y4 logic\n\tassign Y4 = (y[4] & ~w) | (y[5] & w) | (y[6] & ~w);\n\nendmodule\n"}
{"task_id": "mux256to1", "completion": "\tassign out = in[sel];\n\nendmodule\n"}
{"task_id": "2014_q4a", "completion": "\talways @(posedge clk) begin\n\t\tif (L)\n\t\t\tQ <= R;\n\t\telse if (E)\n\t\t\tQ <= w;\n\tend\n\nendmodule\n"}
{"task_id": "ece241_2014_q4", "completion": "\treg q1, q2, q3;\n\twire xor_out, and_out, or_out;\n\n\t// XOR gate\n\tassign xor_out = x ^ q1;\n\n\t// AND gate\n\tassign and_out = x & ~q2;\n\n\t// OR gate\n\tassign or_out = x | ~q3;\n\n\t// D flip-flops\n\talways @(posedge clk) begin\n\t\tq1 <= xor_out;\n\t\tq2 <= and_out;\n\t\tq3 <= or_out;\n\tend\n\n\t// XNOR gate\n\tassign z = ~(q1 ^ q2 ^ q3);\n\nendmodule\n"}
{"task_id": "circuit4", "completion": "\tassign q = (a & b) | (c & d);\n\nendmodule\n"}
{"task_id": "rule110", "completion": "\treg [512:0] q_next;\n\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse\n\t\t\tq <= q_next[511:0];\n\tend\n\n\talways @(*) begin\n\t\tq_next[0] = 1'b0;\n\t\tq_next[512] = 1'b0;\n\t\tfor (int i = 1; i < 512; i = i + 1) begin\n\t\t\tq_next[i] = (q[i-1] == 1'b1 && q[i] == 1'b1 && q[i+1] == 1'b1) ? 1'b0 :\n\t\t\t\t\t\t(q[i-1] == 1'b1 && q[i] == 1'b1 && q[i+1] == 1'b0) ? 1'b1 :\n\t\t\t\t\t\t(q[i-1] == 1'b1 && q[i] == 1'b0 && q[i+1] == 1'b1) ? 1'b1 :\n\t\t\t\t\t\t(q[i-1] == 1'b1 && q[i] == 1'b0 && q[i+1] == 1'b0) ? 1'b0 :\n\t\t\t\t\t\t(q[i-1] == 1'b0 && q[i] == 1'b1 && q[i+1] == 1'b1) ? 1'b1 :\n\t\t\t\t\t\t(q[i-1] == 1'b0 && q[i] == 1'b1 && q[i+1] == 1'b0) ? 1'b1 :\n\t\t\t\t\t\t(q[i-1] == 1'b0 && q[i] == 1'b0 && q[i+1] == 1'b1) ? 1'b1 :\n\t\t\t\t\t\t(q[i-1] == 1'b0 && q[i] == 1'b0 && q[i+1] == 1'b0) ? 1'b0 : 1'b0;\n\t\tend\n\tend\n\nendmodule\n"}
{"task_id": "fsm3s", "completion": "\treg [1:0] state, next_state;\n\n\t// State register\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= 2'b00; // State A\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t2'b00: // State A\n\t\t\t\tnext_state = in ? 2'b10 : 2'b01; // B if in=1, A if in=0\n\t\t\t2'b01: // State B\n\t\t\t\tnext_state = in ? 2'b01 : 2'b10; // B if in=1, C if in=0\n\t\t\t2'b10: // State C\n\t\t\t\tnext_state = in ? 2'b11 : 2'b00; // D if in=1, A if in=0\n\t\t\t2'b11: // State D\n\t\t\t\tnext_state = in ? 2'b01 : 2'b10; // B if in=1, C if in=0\n\t\t\tdefault:\n\t\t\t\tnext_state = 2'b00; // Default to State A\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign out = (state == 2'b11); // 1 when in State D\n\nendmodule\n"}
{"task_id": "circuit5", "completion": "always @(*) begin\n\tq = 4'b0000;\n\tif (a == 4'b0000) q = 4'b0001;\n\telse if (b == 4'b0000) q = 4'b0010;\n\telse if (c == 4'b0000) q = 4'b0011;\n\telse if (d == 4'b0000) q = 4'b0100;\n\telse if (e == 4'b0000) q = 4'b0101;\n\telse if (a == 4'b0001) q = 4'b0110;\n\telse if (b == 4'b0001) q = 4'b0111;\n\telse if (c == 4'b0001) q = 4'b1000;\n\telse if (d == 4'b0001) q = 4'b1001;\n\telse if (e == 4'b0001) q = 4'b1010;\n\telse if (a == 4'b0010) q = 4'b1011;\n\telse if (b == 4'b0010) q = 4'b1100;\n\telse if (c == 4'b0010) q = 4'b1101;\n\telse if (d == 4'b0010) q = 4'b1110;\n\telse if (e == 4'b0010) q = 4'b1111;\n\telse if (a == 4'b0011) q = 4'b1111;\n\telse if (b == 4'b0011) q = 4'b1111;\n\telse if (c == 4'b0011) q = 4'b1111;\n\telse if (d == 4'b0011) q = 4'b1111;\n\telse if (e == 4'b0011) q = 4'b1111;\nend\n\nendmodule\n"}
{"task_id": "bugs_mux2", "completion": "\talways @(*) begin\n\t\tif (sel)\n\t\t\tout = b;\n\t\telse\n\t\t\tout = a;\n\tend\n\nendmodule\n"}
{"task_id": "mt2015_muxdff", "completion": "\twire mux_out;\n\n\t// Instantiate the flipflop submodule\n\tflipflop ff (\n\t\t.clk(clk),\n\t\t.D(mux_out),\n\t\t.Q(Q)\n\t);\n\n\t// Instantiate the 2-1 multiplexer submodule\n\tmux2to1 mux (\n\t\t.A(q_in),\n\t\t.B(r_in),\n\t\t.S(L),\n\t\t.Y(mux_out)\n\t);\n\nendmodule\n\n// Define the flipflop submodule\n\talways @(posedge clk) begin\n\t\tQ <= D;\n\tend\n\nendmodule\n\n// Define the 2-1 multiplexer submodule\n\tassign Y = S ? B : A;\n\nendmodule\n"}
{"task_id": "edgecapture", "completion": "reg [31:0] prev_in;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tout <= 32'b0;\n\t\tprev_in <= 32'b0;\n\tend else begin\n\t\tout <= (prev_in & ~in) | out;\n\t\tprev_in <= in;\n\tend\nend\nendmodule\n"}
{"task_id": "dff8", "completion": "\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "completion": "\twire [8:0] sum;\n\t\n\tassign sum = {a[7], a} + {b[7], b};\n\tassign s = sum[7:0];\n\tassign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "completion": "    // State definitions\n    localparam S = 10'b0000000001;\n    localparam S1 = 10'b0000000010;\n    localparam S11 = 10'b0000000100;\n    localparam S110 = 10'b0000001000;\n    localparam B0 = 10'b0000010000;\n    localparam B1 = 10'b0000100000;\n    localparam B2 = 10'b0001000000;\n    localparam B3 = 10'b0010000000;\n    localparam Count = 10'b0100000000;\n    localparam Wait = 10'b1000000000;\n\n    // Next state logic\n    assign S_next = (state == S && d == 0) ? S :\n                    (state == S && d == 1) ? S1 :\n                    (state == S1 && d == 0) ? S :\n                    (state == S1 && d == 1) ? S11 :\n                    (state == S11 && d == 0) ? S110 :\n                    (state == S11 && d == 1) ? S11 :\n                    (state == S110 && d == 0) ? S :\n                    (state == S110 && d == 1) ? B0 :\n                    (state == B0) ? B1 :\n                    (state == B1) ? B2 :\n                    (state == B2) ? B3 :\n                    (state == B3) ? Count :\n                    (state == Count) ? (done_counting ? Wait : Count) :\n                    (state == Wait) ? (ack ? S : Wait) :\n                    S;\n\n    // Output logic\n    assign done = (state == Wait);\n    assign counting = (state == Count);\n    assign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n    assign B3_next = (state == B3);\n\n    // Note: Count_next and Wait_next are not explicitly defined in the given description\n    // They can be inferred based on the next-state logic and output logic\n\n endmodule\n"}
{"task_id": "counter_2bc", "completion": "    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (state < 2'b11) begin\n                    state <= state + 1'b1; // Increment if less than 3\n                end\n            end else begin\n                if (state > 2'b00) begin\n                    state <= state - 1'b1; // Decrement if greater than 0\n                end\n            end\n        end\n    end\n\nendmodule\n"}
{"task_id": "always_casez", "completion": "always @(*) begin\n\tcasez (in)\n\t\t8'b???????1: pos = 3'd0;\n\t\t8'b??????10: pos = 3'd1;\n\t\t8'b?????100: pos = 3'd2;\n\t\t8'b????1000: pos = 3'd3;\n\t\t8'b???10000: pos = 3'd4;\n\t\t8'b??100000: pos = 3'd5;\n\t\t8'b?1000000: pos = 3'd6;\n\t\t8'b10000000: pos = 3'd7;\n\t\tdefault: pos = 3'd0;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "always_nolatches", "completion": "always @(*) begin\n\tleft = 0;\n\tdown = 0;\n\tright = 0;\n\tup = 0;\n\n\tcase (scancode)\n\t\t16'he06b: left = 1;\n\t\t16'he072: down = 1;\n\t\t16'he074: right = 1;\n\t\t16'he075: up = 1;\n\t\tdefault: begin\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q4j", "completion": "\twire [3:0] carry;\n\n\tfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(carry[0]));\n\tfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n\tfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n\tfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(carry[2]), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n"}
{"task_id": "history_shift", "completion": "    logic [31:0] history;\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            history <= {train_history, train_taken};\n        end\n        else if (predict_valid) begin\n            history <= {history[30:0], predict_taken};\n        end\n    end\n\n    assign predict_history = history;\n\nendmodule\n"}
{"task_id": "wire_decl", "completion": "\twire w1, w2;\n\n\tand (w1, a, b);\n\tand (w2, c, d);\n\tor (out, w1, w2);\n\tnot (out_n, out);\n\nendmodule\n"}
{"task_id": "dff", "completion": "\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q12", "completion": "    reg [7:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_reg <= {shift_reg[6:0], S};\n        end\n    end\n\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bx;\n        endcase\n    end\n\nendmodule\n"}
{"task_id": "thermostat", "completion": "\tassign heater = mode & too_cold;\n\tassign aircon = ~mode & too_hot;\n\tassign fan = (heater | aircon) | fan_on;\n\nendmodule\n"}
{"task_id": "ece241_2013_q2", "completion": "\t// Sum-of-Products (SOP) implementation\n\twire term1, term2, term3, term4, term5, term6, term7, term8, term9, term10, term11, term12, term13, term14, term15;\n\n\tassign term1 = ~a & ~b & ~c & ~d;\n\tassign term2 = ~a & ~b & ~c & d;\n\tassign term3 = ~a & ~b & c & ~d;\n\tassign term4 = ~a & ~b & c & d;\n\tassign term5 = ~a & b & ~c & ~d;\n\tassign term6 = ~a & b & ~c & d;\n\tassign term7 = ~a & b & c & ~d;\n\tassign term8 = ~a & b & c & d;\n\tassign term9 = a & ~b & ~c & ~d;\n\tassign term10 = a & ~b & ~c & d;\n\tassign term11 = a & ~b & c & ~d;\n\tassign term12 = a & ~b & c & d;\n\tassign term13 = a & b & ~c & ~d;\n\tassign term14 = a & b & ~c & d;\n\tassign term15 = a & b & c & ~d;\n\n\tassign out_sop = term1 | term2 | term3 | term4 | term5 | term6 | term7 | term8 | term9 | term10 | term11 | term12 | term13 | term14 | term15;\n\n\t// Product-of-Sums (POS) implementation\n\twire pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, pos9, pos10, pos11, pos12, pos13, pos14, pos15;\n\n\tassign pos1 = (a | b | c | d) & (a | b | c | ~d) & (a | b | ~c | d) & (a | b | ~c | ~d) & (a | ~b | c | d) & (a | ~b | c | ~d) & (a | ~b | ~c | d) & (~a | b | c | d);\n\tassign pos2 = (a | b | c | ~d) & (a | b | ~c | d) & (a | b | ~c | ~d) & (a | ~b | c | d) & (a | ~b | c | ~d) & (a | ~b | ~c | d) & (~a | b | c | d);\n\tassign pos3 = (a | b | ~c | d) & (a | b | ~c | ~d) & (a | ~b | c | d) & (a | ~b | c | ~d) & (a | ~b | ~c | d) & (~a | b | c | d);\n\tassign pos4 = (a | b | ~c | ~d) & (a | ~b | c | d) & (a | ~b | c | ~d) & (a | ~b | ~c | d) & (~a | b | c | d);\n\tassign pos5 = (a | ~b | c | d) & (a | ~b | c | ~d) & (a | ~b | ~c | d) & (~a | b | c | d);\n\tassign pos6 = (a | ~b | c | ~d) & (a | ~b | ~c | d) & (~a | b | c | d);\n\tassign pos7 = (a | ~b | ~c | d) & (~a | b | c | d);\n\tassign pos8 = (~a | b | c | d);\n\tassign pos9 = (a | b | c | ~d);\n\tassign pos10 = (a | b | ~c | d);\n\tassign pos11 = (a | b | ~c | ~d);\n\tassign pos12 = (a | ~b | c | d);\n\tassign pos13 = (a | ~b | c | ~d);\n\tassign pos14 = (a | ~b | ~c | d);\n\tassign pos15 = (~a | b | c | d);\n\n\tassign out_pos = pos1 & pos2 & pos3 & pos4 & pos5 & pos6 & pos7 & pos8 & pos9 & pos10 & pos11 & pos12 & pos13 & pos14 & pos15;\n\nendmodule\n"}
{"task_id": "lfsr32", "completion": "\twire feedback;\n\n\tassign feedback = q[31] ^ q[21] ^ q[1] ^ q[0];\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= {q[30:0], feedback};\n\tend\n\nendmodule\n"}
{"task_id": "circuit3", "completion": "\tassign q = (a & b) | (c & d);\n\nendmodule\n"}
{"task_id": "7420", "completion": "\twire nand_out1, nand_out2;\n\n\t// NAND gate 1\n\tassign nand_out1 = ~(p1a & p1b & p1c & p1d);\n\n\t// NAND gate 2\n\tassign nand_out2 = ~(p2a & p2b & p2c & p2d);\n\n\t// Output assignment\n\tassign p1y = nand_out1;\n\tassign p2y = nand_out2;\n\nendmodule\n"}
{"task_id": "popcount255", "completion": "integer i;\n\nalways @(*) begin\n\tout = 8'b0;\n\tfor (i = 0; i < 255; i = i + 1) begin\n\t\tout = out + in[i];\n\tend\nend\n\nendmodule\n"}
{"task_id": "gatesv", "completion": "\t// out_both\n\tassign out_both[2] = in[2] & in[3];\n\tassign out_both[1] = in[1] & in[2];\n\tassign out_both[0] = in[0] & in[1];\n\n\t// out_any\n\tassign out_any[3] = in[3] | in[2];\n\tassign out_any[2] = in[2] | in[1];\n\tassign out_any[1] = in[1] | in[0];\n\n\t// out_different\n\tassign out_different[3] = in[3] ^ in[0];\n\tassign out_different[2] = in[2] ^ in[3];\n\tassign out_different[1] = in[1] ^ in[2];\n\tassign out_different[0] = in[0] ^ in[1];\n\nendmodule\n"}
{"task_id": "circuit6", "completion": "always @(*) begin\n\tcase (a)\n\t\t3'b000: q = 16'h1232;\n\t\t3'b001: q = 16'haee0;\n\t\t3'b010: q = 16'h27d4;\n\t\t3'b011: q = 16'h5a0e;\n\t\t3'b100: q = 16'h2066;\n\t\t3'b101: q = 16'h64ce;\n\t\t3'b110: q = 16'hc526;\n\t\t3'b111: q = 16'h2f19;\n\t\tdefault: q = 16'hxxxx;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "countslow", "completion": "\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'b0000;\n\t\telse if (slowena)\n\t\t\tq <= (q == 4'b1001) ? 4'b0000 : q + 1'b1;\n\tend\nendmodule\n"}
{"task_id": "m2014_q4f", "completion": "\talways_comb begin\n\t\tout = in1 & in2;\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q4h", "completion": "\tassign out = in;\n\nendmodule\n"}
{"task_id": "fsm1", "completion": "\twire [1:0] state, next_state;\n\treg [1:0] state_reg;\n\n\tassign state = state_reg;\n\tassign next_state = (state[0] & ~in) ? 2'b01 :\n\t                    (state[1] & in)   ? 2'b01 :\n\t                    (state[0] & in)   ? 2'b00 :\n\t                    2'b01;\n\n\tassign out = state[1];\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate_reg <= 2'b01;\n\t\telse\n\t\t\tstate_reg <= next_state;\n\tend\n\nendmodule\n"}
{"task_id": "dualedge", "completion": "\treg q_pos, q_neg;\n\n\talways @(posedge clk) begin\n\t\tq_pos <= d;\n\tend\n\n\talways @(negedge clk) begin\n\t\tq_neg <= d;\n\tend\n\n\talways @(q_pos or q_neg) begin\n\t\tq <= clk ? q_pos : q_neg;\n\tend\n\nendmodule\n"}
{"task_id": "xnorgate", "completion": "\twire not_a, not_b;\n\twire and1_out, and2_out;\n\n\tnot(not_a, a);\n\tnot(not_b, b);\n\n\tand(and1_out, a, b);\n\tand(and2_out, not_a, not_b);\n\n\tor(out, and1_out, and2_out);\n\nendmodule\n"}
{"task_id": "mt2015_q4", "completion": "\twire a1_out, a2_out, b1_out, b2_out;\n\twire or_out, and_out;\n\n\tA a1(.x(x), .y(y), .z(a1_out));\n\tA a2(.x(x), .y(y), .z(a2_out));\n\tB b1(.x(x), .y(y), .z(b1_out));\n\tB b2(.x(x), .y(y), .z(b2_out));\n\n\tassign or_out = a1_out | b1_out;\n\tassign and_out = a2_out & b2_out;\n\tassign z = or_out ^ and_out;\nendmodule\n\n\tassign z = (x ^ y) & x;\nendmodule\n\n\treg z;\n\talways @(x or y) begin\n\t\tcase ({x, y})\n\t\t\t2'b00: z = 1'b1;\n\t\t\t2'b01: z = 1'b0;\n\t\t\t2'b10: z = 1'b0;\n\t\t\t2'b11: z = 1'b1;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "rotate100", "completion": "\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend\n\t\telse begin\n\t\t\tcase (ena)\n\t\t\t\t2'b01: q <= {q[0], q[99:1]}; // Rotate right\n\t\t\t\t2'b10: q <= {q[98:0], q[99]}; // Rotate left\n\t\t\t\tdefault: q <= q; // No rotation\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "review2015_count1k", "completion": "\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 10'd0;\n\t\telse if (q == 10'd999)\n\t\t\tq <= 10'd0;\n\t\telse\n\t\t\tq <= q + 1'b1;\n\tend\nendmodule\n"}
{"task_id": "notgate", "completion": "\tassign out = ~in;\n\nendmodule\n"}
{"task_id": "fsm_onehot", "completion": "\t// State transition logic\n\tassign next_state[0] = (state[0] & ~in) | (state[1] & in);\n\tassign next_state[1] = (state[1] & ~in) | (state[2] & in);\n\tassign next_state[2] = (state[2] & ~in) | (state[3] & in);\n\tassign next_state[3] = (state[3] & ~in) | (state[4] & in);\n\tassign next_state[4] = (state[4] & ~in) | (state[5] & in);\n\tassign next_state[5] = (state[5] & ~in) | (state[6] & in);\n\tassign next_state[6] = (state[6] & ~in) | (state[7] & in);\n\tassign next_state[7] = (state[7] & ~in) | (state[7] & in);\n\tassign next_state[8] = (state[8] & ~in) | (state[9] & in);\n\tassign next_state[9] = (state[9] & ~in) | (state[0] & in);\n\n\t// Output logic\n\tassign out1 = (state[5] | state[6] | state[7]) & ~in;\n\tassign out2 = (state[8] | state[9]) & in;\n\nendmodule\n"}
{"task_id": "ece241_2013_q7", "completion": "\treg Qold;\n\n\talways @(posedge clk) begin\n\t\tQold <= Q;\n\tend\n\n\talways @(*) begin\n\t\tcase ({j, k})\n\t\t\t2'b00: Q = Qold;\n\t\t\t2'b01: Q = 1'b0;\n\t\t\t2'b10: Q = 1'b1;\n\t\t\t2'b11: Q = ~Qold;\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "popcount3", "completion": "\tassign out[0] = in[0] ^ in[1] ^ in[2];\n\tassign out[1] = (in[0] & in[1]) | (in[1] & in[2]) | (in[0] & in[2]);\n\nendmodule\n"}
{"task_id": "vector5", "completion": "\tassign out[24] = ~a ^ a;\n\tassign out[23] = ~a ^ b;\n\tassign out[22] = ~a ^ c;\n\tassign out[21] = ~a ^ d;\n\tassign out[20] = ~a ^ e;\n\tassign out[19] = ~b ^ a;\n\tassign out[18] = ~b ^ b;\n\tassign out[17] = ~b ^ c;\n\tassign out[16] = ~b ^ d;\n\tassign out[15] = ~b ^ e;\n\tassign out[14] = ~c ^ a;\n\tassign out[13] = ~c ^ b;\n\tassign out[12] = ~c ^ c;\n\tassign out[11] = ~c ^ d;\n\tassign out[10] = ~c ^ e;\n\tassign out[9] = ~d ^ a;\n\tassign out[8] = ~d ^ b;\n\tassign out[7] = ~d ^ c;\n\tassign out[6] = ~d ^ d;\n\tassign out[5] = ~d ^ e;\n\tassign out[4] = ~e ^ a;\n\tassign out[3] = ~e ^ b;\n\tassign out[2] = ~e ^ c;\n\tassign out[1] = ~e ^ d;\n\tassign out[0] = ~e ^ e;\n\nendmodule\n"}
{"task_id": "lemmings1", "completion": "\t// State encoding\n\tlocalparam WALK_LEFT = 1'b0;\n\tlocalparam WALK_RIGHT = 1'b1;\n\n\t// State register\n\treg state, next_state;\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (bump_left)\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (bump_right)\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\tend\n\t\t\tdefault: next_state = WALK_LEFT;\n\t\tendcase\n\tend\n\n\t// State register update\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= WALK_LEFT;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Output logic\n\tassign walk_left = (state == WALK_LEFT);\n\tassign walk_right = (state == WALK_RIGHT);\n\nendmodule\n"}
{"task_id": "circuit1", "completion": "\tassign q = a & b;\n\nendmodule\n"}
{"task_id": "7458", "completion": "\twire and1_out, and2_out, and3_out, and4_out;\n\n\tassign and1_out = p1a & p1b & p1c;\n\tassign and2_out = p1d & p1e & p1f;\n\tassign and3_out = p2a & p2b;\n\tassign and4_out = p2c & p2d;\n\n\tassign p1y = and1_out | and2_out;\n\tassign p2y = and3_out | and4_out;\n\nendmodule\n"}
{"task_id": "2014_q3c", "completion": "\treg [2:0] next_state;\n\n\talways @(*) begin\n\t\tcase (y)\n\t\t\t3'b000: next_state = x ? 3'b100 : 3'b001;\n\t\t\t3'b001: next_state = x ? 3'b001 : 3'b100;\n\t\t\t3'b010: next_state = x ? 3'b001 : 3'b010;\n\t\t\t3'b011: next_state = x ? 3'b010 : 3'b001;\n\t\t\t3'b100: next_state = x ? 3'b011 : 3'b100;\n\t\t\tdefault: next_state = 3'b000;\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\ty <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (y)\n\t\t\t3'b000: Y0 = 1'b0;\n\t\t\t3'b001: Y0 = 1'b0;\n\t\t\t3'b010: Y0 = 1'b0;\n\t\t\t3'b011: Y0 = 1'b1;\n\t\t\t3'b100: Y0 = 1'b1;\n\t\t\tdefault: Y0 = 1'b0;\n\t\tendcase\n\tend\n\n\talways @(*) begin\n\t\tz = (y == 3'b011) || (y == 3'b100);\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q4e", "completion": "\talways @(*) begin\n\t\tout = ~(in1 | in2);\n\tend\n\nendmodule\n"}
{"task_id": "wire4", "completion": "\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule\n"}
{"task_id": "m2014_q4b", "completion": "\talways_ff @(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 1'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"task_id": "always_case", "completion": "always @(*) begin\n\tcase (sel)\n\t\t3'd0: out = data0;\n\t\t3'd1: out = data1;\n\t\t3'd2: out = data2;\n\t\t3'd3: out = data3;\n\t\t3'd4: out = data4;\n\t\t3'd5: out = data5;\n\t\tdefault: out = 4'b0000;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "timer", "completion": "reg [9:0] counter;\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tcounter <= data;\n\tend else if (counter != 0) begin\n\t\tcounter <= counter - 1;\n\tend\nend\n\nassign tc = (counter == 0);\n\nendmodule\n"}
{"task_id": "review2015_fsmseq", "completion": "\treg [2:0] state;\n\treg [2:0] next_state;\n\n\tlocalparam IDLE = 3'b000;\n\tlocalparam S1 = 3'b001;\n\tlocalparam S11 = 3'b010;\n\tlocalparam S110 = 3'b011;\n\tlocalparam S1101 = 3'b100;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (data == 1'b1)\n\t\t\t\t\tnext_state = S1;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (data == 1'b1)\n\t\t\t\t\tnext_state = S11;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tS11: begin\n\t\t\t\tif (data == 1'b0)\n\t\t\t\t\tnext_state = S110;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S11;\n\t\t\tend\n\t\t\tS110: begin\n\t\t\t\tif (data == 1'b1)\n\t\t\t\t\tnext_state = S1101;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tS1101: begin\n\t\t\t\tif (data == 1'b1)\n\t\t\t\t\tnext_state = S1101;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\n\tassign start_shifting = (state == S1101);\n\nendmodule\n"}
{"task_id": "dff8r", "completion": "\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 8'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "edgedetect2", "completion": "reg [7:0] in_prev;\n\nalways @(posedge clk) begin\n\tin_prev <= in;\n\tfor (int i = 0; i < 8; i++) begin\n\t\tif (in[i] && !in_prev[i]) begin\n\t\t\tanyedge[i] <= 1'b1;\n\t\tend else begin\n\t\t\tanyedge[i] <= 1'b0;\n\t\tend\n\tend\nend\nendmodule\n"}
{"task_id": "count1to10", "completion": "\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'd1;\n\t\telse if (q == 4'd10)\n\t\t\tq <= 4'd1;\n\t\telse\n\t\t\tq <= q + 1;\n\tend\nendmodule\n"}
{"task_id": "circuit9", "completion": "always @(posedge clk) begin\n\tif (a) begin\n\t\tq <= q + 1;\n\tend else begin\n\t\tq <= 0;\n\tend\nend\n\nendmodule\n"}
{"task_id": "lfsr5", "completion": "\twire feedback;\n\n\tassign feedback = q[4] ^ q[2];\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 5'b00001;\n\t\telse\n\t\t\tq <= {q[3:0], feedback};\n\tend\n\nendmodule\n"}
{"task_id": "bugs_addsubz", "completion": "\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t1'b0: out = a + b;\n\t\t\t1'b1: out = a - b;\n\t\tendcase\n\n\t\tresult_is_zero = (out == 8'b0);\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q3", "completion": "\talways_comb begin\n\t\tcase ({x[4], x[3], x[2], x[1]})\n\t\t\t4'b0000, 4'b0001, 4'b0101, 4'b0111, 4'b1101, 4'b1111: f = 1'b0;\n\t\t\t4'b0010, 4'b0011, 4'b0110, 4'b1000, 4'b1001, 4'b1011: f = 1'b1;\n\t\t\tdefault: f = 1'bx;\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "bugs_case", "completion": "always @(*) begin\n\tcase (code)\n\t\t8'h45: begin out = 4'd0; valid = 1'b1; end\n\t\t8'h16: begin out = 4'd1; valid = 1'b1; end\n\t\t8'h1e: begin out = 4'd2; valid = 1'b1; end\n\t\t8'h26: begin out = 4'd3; valid = 1'b1; end\n\t\t8'h25: begin out = 4'd4; valid = 1'b1; end\n\t\t8'h2e: begin out = 4'd5; valid = 1'b1; end\n\t\t8'h36: begin out = 4'd6; valid = 1'b1; end\n\t\t8'h3d: begin out = 4'd7; valid = 1'b1; end\n\t\t8'h3e: begin out = 4'd8; valid = 1'b1; end\n\t\t8'h46: begin out = 4'd9; valid = 1'b1; end\n\t\tdefault: begin out = 4'd0; valid = 1'b0; end\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "vectorr", "completion": "\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n"}
{"task_id": "kmap3", "completion": "always @(*) begin\n\tif (a == 0 && b == 0 && c == 0 && d == 0)\n\t\tout = 0;\n\telse if (a == 0 && b == 0 && c == 0 && d == 1)\n\t\tout = 0;\n\telse if (a == 0 && b == 0 && c == 1 && d == 0)\n\t\tout = 1;\n\telse if (a == 0 && b == 0 && c == 1 && d == 1)\n\t\tout = 1;\n\telse if (a == 0 && b == 1 && c == 0 && d == 0)\n\t\tout = 1;\n\telse if (a == 0 && b == 1 && c == 0 && d == 1)\n\t\tout = 1;\n\telse if (a == 0 && b == 1 && c == 1 && d == 0)\n\t\tout = 1;\n\telse if (a == 0 && b == 1 && c == 1 && d == 1)\n\t\tout = 1;\n\telse if (a == 1 && b == 0 && c == 0 && d == 0)\n\t\tout = 1;\n\telse if (a == 1 && b == 0 && c == 0 && d == 1)\n\t\tout = 1;\n\telse if (a == 1 && b == 0 && c == 1 && d == 0)\n\t\tout = 1;\n\telse if (a == 1 && b == 0 && c == 1 && d == 1)\n\t\tout = 1;\n\telse if (a == 1 && b == 1 && c == 0 && d == 0)\n\t\tout = 1;\n\telse if (a == 1 && b == 1 && c == 0 && d == 1)\n\t\tout = 1;\n\telse if (a == 1 && b == 1 && c == 1 && d == 0)\n\t\tout = 1;\n\telse if (a == 1 && b == 1 && c == 1 && d == 1)\n\t\tout = 1;\nend\n\nendmodule\n"}
{"task_id": "review2015_shiftcount", "completion": "\treg [3:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (shift_ena) begin\n\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\tend\n\t\tif (count_ena) begin\n\t\t\tq <= q - 1;\n\t\tend\n\tend\n\n\tinitial begin\n\t\tq = 4'b1111;\n\t\tshift_reg = 4'b0000;\n\tend\n\nendmodule\n"}
{"task_id": "wire", "completion": "\tassign out = in;\n\nendmodule\n"}
{"task_id": "review2015_fsmshift", "completion": "reg [1:0] state;\nreg [1:0] next_state;\nreg [1:0] counter;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 2'b00;\n\t\tcounter <= 2'b00;\n\tend\n\telse begin\n\t\tstate <= next_state;\n\t\tif (state == 2'b00)\n\t\t\tcounter <= counter + 1;\n\t\telse\n\t\t\tcounter <= 2'b00;\n\tend\nend\n\nalways @(*) begin\n\tcase (state)\n\t\t2'b00: next_state = (counter == 2'b11) ? 2'b01 : 2'b00;\n\t\t2'b01: next_state = 2'b10;\n\t\t2'b10: next_state = 2'b11;\n\t\t2'b11: next_state = 2'b11;\n\tendcase\nend\n\nassign shift_ena = (state == 2'b00);\n\nendmodule\n"}
{"task_id": "count15", "completion": "\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'b0000;\n\t\telse\n\t\t\tq <= q + 1'b1;\n\tend\nendmodule\n"}
{"task_id": "always_if", "completion": "\t// Using assign statements\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n\t// Using procedural if statement\n\talways @(*) begin\n\t\tif (sel_b1 & sel_b2)\n\t\t\tout_always = b;\n\t\telse\n\t\t\tout_always = a;\n\tend\n\nendmodule\n"}
{"task_id": "kmap1", "completion": "\tassign out = (a & b) | (a & c) | (b & c);\n\nendmodule\n"}
{"task_id": "2013_q2afsm", "completion": "\t// State encoding\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] current_state, next_state;\n\n\t// State table\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tA: begin\n\t\t\t\tif (r[1]) next_state = B;\n\t\t\t\telse if (r[2]) next_state = C;\n\t\t\t\telse if (r[3]) next_state = D;\n\t\t\t\telse next_state = A;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (r[1]) next_state = B;\n\t\t\t\telse next_state = A;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (r[2]) next_state = C;\n\t\t\t\telse next_state = A;\n\t\t\tend\n\t\t\tD: next_state = A;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\t// State flip-flops\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn)\n\t\t\tcurrent_state <= A;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// Output logic\n\tassign g[1] = (current_state == B);\n\tassign g[2] = (current_state == C);\n\tassign g[3] = (current_state == D);\n\nendmodule\n"}
{"task_id": "count10", "completion": "\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'b0000;\n\t\telse if (q == 4'b1001)\n\t\t\tq <= 4'b0000;\n\t\telse\n\t\t\tq <= q + 1;\n\tend\nendmodule\n"}
{"task_id": "fsm_ps2", "completion": "reg [1:0] state;\nparameter IDLE = 2'b00, WAIT = 2'b01, DONE = 2'b10;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= IDLE;\n\tend else begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in[3]) begin\n\t\t\t\t\tstate <= WAIT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWAIT: begin\n\t\t\t\tif (in[3]) begin\n\t\t\t\t\tstate <= DONE;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= WAIT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tDONE: begin\n\t\t\t\tstate <= IDLE;\n\t\t\tend\n\t\t\tdefault: state <= IDLE;\n\t\tendcase\n\tend\nend\n\nassign done = (state == DONE);\n\nendmodule\n"}
{"task_id": "mux2to1", "completion": "\tassign out = (sel == 0) ? a : b;\n\nendmodule\n"}
{"task_id": "gates4", "completion": "\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule\n"}
{"task_id": "2014_q3bfsm", "completion": "reg [2:0] y, Y0, Y1;\n\nalways @(*) begin\n\tcase (y)\n\t\t3'b000: begin Y0 = 3'b001; Y1 = 3'b001; z = 1'b0; end\n\t\t3'b001: begin Y0 = 3'b100; Y1 = 3'b100; z = 1'b0; end\n\t\t3'b010: begin Y0 = 3'b001; Y1 = 3'b001; z = 1'b0; end\n\t\t3'b011: begin Y0 = 3'b010; Y1 = 3'b001; z = 1'b1; end\n\t\t3'b100: begin Y0 = 3'b011; Y1 = 3'b100; z = 1'b1; end\n\t\tdefault: begin Y0 = 3'b000; Y1 = 3'b000; z = 1'b0; end\n\tendcase\nend\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\ty <= 3'b000;\n\telse\n\t\ty <= x ? Y1 : Y0;\nend\n\nendmodule\n"}
{"task_id": "2013_q2bfsm", "completion": "\treg [2:0] state;\n\treg [1:0] x_history;\n\treg [1:0] y_history;\n\treg g_reg;\n\n\tlocalparam A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tstate <= A;\n\t\t\tx_history <= 2'b00;\n\t\t\ty_history <= 2'b00;\n\t\t\tg_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tstate <= B;\n\t\t\t\t\tg_reg <= 1'b1;\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tstate <= C;\n\t\t\t\t\tx_history <= {x_history[0], x};\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tstate <= D;\n\t\t\t\t\tx_history <= {x_history[0], x};\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tstate <= E;\n\t\t\t\t\tx_history <= {x_history[0], x};\n\t\t\t\tend\n\t\t\t\tE: begin\n\t\t\t\t\tstate <= B;\n\t\t\t\t\ty_history <= {y_history[0], y};\n\t\t\t\t\tif (x_history == 2'b101) begin\n\t\t\t\t\t\tg_reg <= 1'b1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tg_reg <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\t\tif (y_history == 2'b10) begin\n\t\t\t\t\t\tg_reg <= 1'b1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tg_reg <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdefault: state <= A;\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign f = (state == A) ? 1'b1 : 1'b0;\n\tassign g = g_reg;\n\nendmodule\n"}
{"task_id": "dff8p", "completion": "\talways @(negedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 8'h34;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "reduction", "completion": "\tassign parity = ^in;\n\nendmodule\n"}
{"task_id": "fsm3comb", "completion": "always @(*) begin\n\tcase (state)\n\t\t2'b00: begin // State A\n\t\t\tnext_state = in ? 2'b01 : 2'b00;\n\t\tend\n\t\t2'b01: begin // State B\n\t\t\tnext_state = in ? 2'b01 : 2'b10;\n\t\tend\n\t\t2'b10: begin // State C\n\t\t\tnext_state = in ? 2'b11 : 2'b00;\n\t\tend\n\t\t2'b11: begin // State D\n\t\t\tnext_state = in ? 2'b01 : 2'b10;\n\t\tend\n\t\tdefault: next_state = 2'b00;\n\tendcase\nend\n\nassign out = (state == 2'b11);\n\nendmodule\n"}
{"task_id": "mt2015_q4b", "completion": "\twire a, b, c, d;\n\n\tassign a = x & y;\n\tassign b = x | y;\n\tassign c = ~x;\n\tassign d = x ^ y;\n\n\tassign z = (a & b) | (c & d);\n\nendmodule\n"}
{"task_id": "2012_q2fsm", "completion": "\t// State encoding\n\tparameter A = 3'b000;\n\tparameter B = 3'b001;\n\tparameter C = 3'b010;\n\tparameter D = 3'b011;\n\tparameter E = 3'b100;\n\tparameter F = 3'b101;\n\n\t// State register\n\treg [2:0] state, next_state;\n\n\t// State table\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = w ? B : A;\n\t\t\tB: next_state = w ? C : D;\n\t\t\tC: next_state = w ? E : D;\n\t\t\tD: next_state = w ? F : A;\n\t\t\tE: next_state = w ? E : D;\n\t\t\tF: next_state = w ? C : D;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\t// State flip-flops\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Output logic\n\tassign z = (state == E) || (state == F);\n\nendmodule\n"}
{"task_id": "dff16e", "completion": "\treg [15:0] dff;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tdff <= 16'b0;\n\t\tend else begin\n\t\t\tif (byteena[1]) begin\n\t\t\t\tdff[15:8] <= d[15:8];\n\t\t\tend\n\t\t\tif (byteena[0]) begin\n\t\t\t\tdff[7:0] <= d[7:0];\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tq <= dff;\n\tend\n\nendmodule\n"}
{"task_id": "edgedetect", "completion": "reg [7:0] in_prev;\n\nalways @(posedge clk) begin\n\tin_prev <= in;\n\tpedge <= (~in_prev) & in;\nend\nendmodule\n"}
{"task_id": "circuit8", "completion": "\treg [1:0] state;\n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n\talways @(posedge clock) begin\n\t\tcase (state)\n\t\t\tS0: begin\n\t\t\t\tif (a == 0) begin\n\t\t\t\t\tstate <= S1;\n\t\t\t\t\tp <= 0;\n\t\t\t\t\tq <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S0;\n\t\t\t\t\tp <= 0;\n\t\t\t\t\tq <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (a == 0) begin\n\t\t\t\t\tstate <= S2;\n\t\t\t\t\tp <= 0;\n\t\t\t\t\tq <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S0;\n\t\t\t\t\tp <= 0;\n\t\t\t\t\tq <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (a == 1) begin\n\t\t\t\t\tstate <= S3;\n\t\t\t\t\tp <= 1;\n\t\t\t\t\tq <= 1;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S1;\n\t\t\t\t\tp <= 0;\n\t\t\t\t\tq <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS3: begin\n\t\t\t\tif (a == 0) begin\n\t\t\t\t\tstate <= S0;\n\t\t\t\t\tp <= 0;\n\t\t\t\t\tq <= 1;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S2;\n\t\t\t\t\tp <= 1;\n\t\t\t\t\tq <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\tinitial begin\n\t\tstate = S0;\n\t\tp = 0;\n\t\tq = 0;\n\tend\n\nendmodule\n"}
{"task_id": "rule90", "completion": "\treg [512:0] q_next;\n\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse\n\t\t\tq <= q_next[511:0];\n\tend\n\n\talways @(*) begin\n\t\tq_next[0] = q[0] ^ q[1];\n\t\tq_next[511] = q[510] ^ q[511];\n\t\tq_next[512] = q[511] ^ q[0];\n\n\t\tfor (int i = 1; i < 511; i = i + 1) begin\n\t\t\tq_next[i] = q[i-1] ^ q[i] ^ q[i+1];\n\t\tend\n\tend\n\nendmodule\n"}
{"task_id": "mt2015_eq2", "completion": "\tassign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "gatesv100", "completion": "\t// out_both\n\tgenvar i;\n\tgenerate\n\t\tfor (i = 0; i < 99; i = i + 1) begin : gen_out_both\n\t\t\tassign out_both[i] = in[i] & in[i+1];\n\t\tend\n\tendgenerate\n\n\t// out_any\n\tgenerate\n\t\tfor (i = 1; i < 100; i = i + 1) begin : gen_out_any\n\t\t\tassign out_any[i] = in[i] | in[i-1];\n\t\tend\n\tendgenerate\n\n\t// out_different\n\tgenerate\n\t\tfor (i = 0; i < 100; i = i + 1) begin : gen_out_different\n\t\t\tif (i == 99)\n\t\t\t\tassign out_different[i] = in[i] ^ in[0];\n\t\t\telse\n\t\t\t\tassign out_different[i] = in[i] ^ in[i+1];\n\t\tend\n\tendgenerate\n\nendmodule\n"}
{"task_id": "m2014_q4a", "completion": "\talways @(d or ena) begin\n\t\tif (ena) begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule\n"}
{"task_id": "mux256to1v", "completion": "\tassign out = in[sel*4 +: 4];\n\nendmodule\n"}
{"task_id": "mux9to1v", "completion": "always_comb begin\n\tcase(sel)\n\t\t4'd0: out = a;\n\t\t4'd1: out = b;\n\t\t4'd2: out = c;\n\t\t4'd3: out = d;\n\t\t4'd4: out = e;\n\t\t4'd5: out = f;\n\t\t4'd6: out = g;\n\t\t4'd7: out = h;\n\t\t4'd8: out = i;\n\t\tdefault: out = 16'hFFFF;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "vectorgates", "completion": "\t// Bitwise OR\n\tassign out_or_bitwise = a | b;\n\n\t// Logical OR\n\tassign out_or_logical = |a | |b;\n\n\t// Inverse (NOT) of a in lower half, b in upper half\n\tassign out_not = {~b, ~a};\n\nendmodule\n"}
{"task_id": "fsm3onehot", "completion": "\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t4'b0001: next_state = in ? 4'b0010 : 4'b0001;\n\t\t\t4'b0010: next_state = in ? 4'b0010 : 4'b0100;\n\t\t\t4'b0100: next_state = in ? 4'b1000 : 4'b0001;\n\t\t\t4'b1000: next_state = in ? 4'b0010 : 4'b0100;\n\t\t\tdefault: next_state = 4'b0001;\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign out = (state == 4'b1000);\n\nendmodule\n"}
{"task_id": "conditional", "completion": "always @(*) begin\n\tif (a <= b && a <= c && a <= d)\n\t\tmin = a;\n\telse if (b <= a && b <= c && b <= d)\n\t\tmin = b;\n\telse if (c <= a && c <= b && c <= d)\n\t\tmin = c;\n\telse\n\t\tmin = d;\nend\n\nendmodule\n"}
{"task_id": "gates", "completion": "\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\n\nendmodule\n"}
{"task_id": "kmap2", "completion": "\twire not_a, not_b, not_c, not_d;\n\twire term1, term2, term3, term4;\n\n\tnot (not_a, a);\n\tnot (not_b, b);\n\tnot (not_c, c);\n\tnot (not_d, d);\n\n\tand (term1, not_a, not_b, c, d);\n\tand (term2, not_a, b, not_c, d);\n\tand (term3, a, not_b, not_c, not_d);\n\tand (term4, a, b, c, d);\n\n\tor (out, term1, term2, term3, term4);\n\nendmodule\n"}
{"task_id": "2014_q3fsm", "completion": "reg [2:0] state;\nreg [1:0] count;\n\nlocalparam A = 3'b000, B = 3'b001;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= A;\n\t\tcount <= 2'b00;\n\t\tz <= 1'b0;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (s) state <= B;\n\t\t\t\tz <= 1'b0;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (count == 2'b11) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\t\tcount <= 2'b00;\n\t\t\t\tend else begin\n\t\t\t\t\tcount <= count + 1'b1;\n\t\t\t\t\tif (w) z <= 1'b1;\n\t\t\t\t\telse z <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: state <= A;\n\t\tendcase\n\tend\nend\n\nendmodule\n"}
{"task_id": "vector4", "completion": "\tassign out = {{24{in[7]}}, in};\n\nendmodule\n"}
{"task_id": "m2014_q4k", "completion": "\treg [3:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tshift_reg <= 4'b0000;\n\t\tend else begin\n\t\t\tshift_reg <= {shift_reg[2:0], in};\n\t\tend\n\tend\n\n\tassign out = shift_reg[3];\n\nendmodule\n"}
{"task_id": "always_case2", "completion": "always @(*) begin\n\tcase (in)\n\t\t4'b0000: pos = 2'b00;\n\t\t4'b0001: pos = 2'b00;\n\t\t4'b0010: pos = 2'b01;\n\t\t4'b0011: pos = 2'b00;\n\t\t4'b0100: pos = 2'b10;\n\t\t4'b0101: pos = 2'b00;\n\t\t4'b0110: pos = 2'b01;\n\t\t4'b0111: pos = 2'b00;\n\t\t4'b1000: pos = 2'b11;\n\t\t4'b1001: pos = 2'b00;\n\t\t4'b1010: pos = 2'b01;\n\t\t4'b1011: pos = 2'b00;\n\t\t4'b1100: pos = 2'b10;\n\t\t4'b1101: pos = 2'b00;\n\t\t4'b1110: pos = 2'b01;\n\t\t4'b1111: pos = 2'b00;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "fsm2", "completion": "\treg state, next_state;\n\tparameter OFF = 1'b0, ON = 1'b1;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j)\n\t\t\t\t\tnext_state = ON;\n\t\t\t\telse\n\t\t\t\t\tnext_state = OFF;\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k)\n\t\t\t\t\tnext_state = OFF;\n\t\t\t\telse\n\t\t\t\t\tnext_state = ON;\n\t\t\tend\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\tassign out = (state == ON);\n\nendmodule\n"}
{"task_id": "m2014_q4i", "completion": "\tassign out = 1'b0;\n\nendmodule\n"}
{"task_id": "step_one", "completion": "\tassign one = 1'b1;\n\nendmodule\n"}
{"task_id": "vector100r", "completion": "integer i;\n\nalways @(*) begin\n\tfor (i = 0; i < 100; i = i + 1) begin\n\t\tout[i] = in[99-i];\n\tend\nend\n\nendmodule\n"}
{"task_id": "m2014_q4d", "completion": "\tlogic xor_out;\n\n\talways @(posedge clk) begin\n\t\txor_out <= in ^ out;\n\t\tout <= xor_out;\n\tend\n\nendmodule\n"}
{"task_id": "shift4", "completion": "\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tq <= 4'b0000;\n\t\tend\n\t\telse if (load) begin\n\t\t\tq <= data;\n\t\tend\n\t\telse if (ena) begin\n\t\t\tq <= {1'b0, q[3:1]};\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "truthtable1", "completion": "assign f = (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & ~x2 & ~x1) | (x3 & x2 & x1);\n\nendmodule\n"}
{"task_id": "dff8ar", "completion": "\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tq <= 8'b0;\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule\n"}
{"task_id": "gates100", "completion": "\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule\n"}
{"task_id": "hadd", "completion": "\tassign sum = a ^ b;\n\tassign cout = a & b;\n\nendmodule\n"}
{"task_id": "always_if2", "completion": "\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1'b1;\n\t\telse\n\t\t\tshut_off_computer = 1'b0;\n\tend\n\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = ~gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\nendmodule\n"}
{"task_id": "fsm2s", "completion": "\treg state, next_state;\n\tparameter OFF = 1'b0, ON = 1'b1;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j)\n\t\t\t\t\tnext_state = ON;\n\t\t\t\telse\n\t\t\t\t\tnext_state = OFF;\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k)\n\t\t\t\t\tnext_state = OFF;\n\t\t\t\telse\n\t\t\t\t\tnext_state = ON;\n\t\t\tend\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\n\tassign out = state;\n\nendmodule\n"}
{"task_id": "vector3", "completion": "\twire [29:0] concatenated;\n\tassign concatenated = {a, b, c, d, e, f};\n\n\tassign w = concatenated[29:22];\n\tassign x = concatenated[21:14];\n\tassign y = concatenated[13:6];\n\tassign z = {concatenated[5:0], 2'b11};\n\nendmodule\n"}
{"task_id": "circuit2", "completion": "\tassign q = (a & b & c & d) | (~a & ~b & ~c & ~d);\n\nendmodule\n"}
{"task_id": "andgate", "completion": "\tassign out = a & b;\n\nendmodule\n"}
{"task_id": "fsm1s", "completion": "reg state, next_state;\nparameter A = 1'b0, B = 1'b1;\n\nalways @(posedge clk) begin\n\tif (reset)\n\t\tstate <= B;\n\telse\n\t\tstate <= next_state;\nend\n\nalways @(*) begin\n\tcase (state)\n\t\tB: begin\n\t\t\tif (in == 0)\n\t\t\t\tnext_state = A;\n\t\t\telse\n\t\t\t\tnext_state = B;\n\t\tend\n\t\tA: begin\n\t\t\tif (in == 0)\n\t\t\t\tnext_state = B;\n\t\t\telse\n\t\t\t\tnext_state = A;\n\t\tend\n\tendcase\nend\n\nassign out = (state == B);\n\nendmodule\n"}
{"task_id": "fadd", "completion": "\twire w1, w2, w3;\n\n\tassign w1 = a ^ b;\n\tassign w2 = w1 & cin;\n\tassign w3 = a & b;\n\tassign sum = w1 ^ cin;\n\tassign cout = w2 | w3;\n\nendmodule\n"}
{"task_id": "m2014_q4g", "completion": "\tlogic xnor_out;\n\n\talways @(*) begin\n\t\txnor_out = ~(in1 ^ in2);\n\t\tout = xnor_out ^ in3;\n\tend\n\nendmodule\n"}
{"task_id": "ece241_2014_q3", "completion": "\twire [1:0] ab;\n\tassign ab = {c, d};\n\n\tmux_4to1 mux (\n\t\t.in({mux_in[3], mux_in[2], mux_in[1], mux_in[0]}),\n\t\t.sel(ab),\n\t\t.out(mux_in[3])\n\t);\n\n\tmux_2to1 mux1 (\n\t\t.in({mux_in[2], mux_in[1]}),\n\t\t.sel(d),\n\t\t.out(mux_in[2])\n\t);\n\n\tmux_2to1 mux2 (\n\t\t.in({mux_in[3], mux_in[0]}),\n\t\t.sel(d),\n\t\t.out(mux_in[1])\n\t);\n\n\tmux_2to1 mux3 (\n\t\t.in({1'b1, 1'b0}),\n\t\t.sel(c),\n\t\t.out(mux_in[0])\n\t);\n\n\tmux_2to1 mux4 (\n\t\t.in({1'b1, 1'b0}),\n\t\t.sel(c),\n\t\t.out(mux_in[3])\n\t);\n\nendmodule\n\n\tassign out = (sel == 2'b00) ? in[0] :\n\t             (sel == 2'b01) ? in[1] :\n\t             (sel == 2'b11) ? in[2] :\n\t             in[3];\n\nendmodule\n\n\tassign out = sel ? in[1] : in[0];\n\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "completion": "\treg [1:0] state, next_state;\n\tparameter A = 2'b00, B = 2'b01;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (x)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (x)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = B;\n\t\t\tend\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\tassign z = (state == B) ? ~x : x;\n\nendmodule\n"}
{"task_id": "circuit10", "completion": "reg state_reg;\n\nalways @(posedge clk) begin\n\tif (a == 1 && b == 1) begin\n\t\tstate_reg <= 1;\n\tend else if (a == 0 && b == 0) begin\n\t\tstate_reg <= 0;\n\tend\nend\n\nassign q = state_reg;\nassign state = state_reg;\n\nendmodule\n"}
{"task_id": "2012_q1g", "completion": "\talways_comb begin\n\t\tcase ({x[4], x[3], x[2], x[1]})\n\t\t\t4'b0000: f = 1'b1;\n\t\t\t4'b0001: f = 1'b0;\n\t\t\t4'b0011: f = 1'b0;\n\t\t\t4'b0010: f = 1'b1;\n\t\t\t4'b0100: f = 1'b1;\n\t\t\t4'b0101: f = 1'b0;\n\t\t\t4'b0111: f = 1'b1;\n\t\t\t4'b0110: f = 1'b0;\n\t\t\t4'b1100: f = 1'b1;\n\t\t\t4'b1101: f = 1'b1;\n\t\t\t4'b1111: f = 1'b0;\n\t\t\t4'b1110: f = 1'b0;\n\t\t\t4'b1000: f = 1'b1;\n\t\t\t4'b1001: f = 1'b0;\n\t\t\t4'b1011: f = 1'b1;\n\t\t\t4'b1010: f = 1'b0;\n\t\t\tdefault: f = 1'b0;\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "fsm_hdlc", "completion": "\treg [2:0] state;\n\treg [2:0] next_state;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= 3'b000;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t3'b000: next_state = in ? 3'b001 : 3'b000;\n\t\t\t3'b001: next_state = in ? 3'b010 : 3'b000;\n\t\t\t3'b010: next_state = in ? 3'b011 : 3'b000;\n\t\t\t3'b011: next_state = in ? 3'b100 : 3'b000;\n\t\t\t3'b100: next_state = in ? 3'b101 : 3'b000;\n\t\t\t3'b101: next_state = in ? 3'b110 : 3'b000;\n\t\t\t3'b110: next_state = in ? 3'b111 : 3'b000;\n\t\t\t3'b111: next_state = in ? 3'b111 : 3'b000;\n\t\t\tdefault: next_state = 3'b000;\n\t\tendcase\n\tend\n\n\tassign disc = (state == 3'b111) && !in;\n\tassign flag = (state == 3'b111) && in;\n\tassign err = (state == 3'b111) && in;\n\nendmodule\n"}
{"task_id": "review2015_fancytimer", "completion": "    localparam IDLE = 3'b000,\n               SEARCH_1101 = 3'b001,\n               SEARCH_DELAY = 3'b010,\n               COUNTING = 3'b011,\n               DONE = 3'b100;\n\n    reg [2:0] state, next_state;\n    reg [3:0] delay;\n    reg [12:0] timer;\n    reg [3:0] remaining_time;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            delay <= 4'b0;\n            timer <= 13'b0;\n            remaining_time <= 4'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                SEARCH_1101: begin\n                    if (data == 1'b1) begin\n                        delay <= {delay[2:0], 1'b1};\n                        if (delay[3:1] == 3'b110) begin\n                            next_state <= SEARCH_DELAY;\n                        end\n                    end else begin\n                        delay <= 4'b0;\n                    end\n                end\n                SEARCH_DELAY: begin\n                    if (data == 1'b1) begin\n                        delay <= {delay[2:0], 1'b1};\n                        if (delay == 4'b1111) begin\n                            next_state <= COUNTING;\n                            remaining_time <= delay;\n                            timer <= 13'b0;\n                            counting <= 1'b1;\n                        end\n                    end else begin\n                        delay <= 4'b0;\n                        next_state <= SEARCH_1101;\n                    end\n                end\n                COUNTING: begin\n                    timer <= timer + 1'b1;\n                    if (timer == 13'd999) begin\n                        timer <= 13'b0;\n                        if (remaining_time == 4'b0) begin\n                            next_state <= DONE;\n                            done <= 1'b1;\n                        end else begin\n                            remaining_time <= remaining_time - 1'b1;\n                        end\n                    end\n                end\n                DONE: begin\n                    if (ack) begin\n                        next_state <= IDLE;\n                        counting <= 1'b0;\n                        done <= 1'b0;\n                    end\n                end\n                default: next_state <= IDLE;\n            endcase\n        end\n    end\n\n    assign count = (state == COUNTING) ? remaining_time : 4'bxxxx;\n\nendmodule\n"}
{"task_id": "ece241_2013_q4", "completion": "reg [1:0] state;\nparameter LOW = 2'b00, MEDIUM = 2'b01, HIGH = 2'b10, VERY_HIGH = 2'b11;\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= LOW;\n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b1;\n\t\tdfr <= 1'b1;\n\tend else begin\n\t\tcase (state)\n\t\t\tLOW: begin\n\t\t\t\tif (s[1]) state <= MEDIUM;\n\t\t\t\telse state <= LOW;\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= 1'b1;\n\t\t\t\tdfr <= 1'b1;\n\t\t\tend\n\t\t\tMEDIUM: begin\n\t\t\t\tif (s[2]) state <= HIGH;\n\t\t\t\telse if (s[1]) state <= MEDIUM;\n\t\t\t\telse state <= LOW;\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= 1'b1;\n\t\t\t\tdfr <= 1'b0;\n\t\t\tend\n\t\t\tHIGH: begin\n\t\t\t\tif (s[3]) state <= VERY_HIGH;\n\t\t\t\telse if (s[2]) state <= HIGH;\n\t\t\t\telse if (s[1]) state <= MEDIUM;\n\t\t\t\telse state <= LOW;\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b0;\n\t\t\tend\n\t\t\tVERY_HIGH: begin\n\t\t\t\tif (!s[3]) state <= HIGH;\n\t\t\t\telse if (s[3]) state <= VERY_HIGH;\n\t\t\t\telse if (s[2]) state <= HIGH;\n\t\t\t\telse if (s[1]) state <= MEDIUM;\n\t\t\t\telse state <= LOW;\n\t\t\t\tfr3 <= 1'b0;\n\t\t\t\tfr2 <= 1'b0;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule\n"}
{"task_id": "fsm_serial", "completion": "\treg [2:0] state;\n\treg [3:0] bit_count;\n\treg [7:0] data;\n\n\tlocalparam IDLE = 3'b000;\n\tlocalparam START = 3'b001;\n\tlocalparam DATA = 3'b010;\n\tlocalparam STOP = 3'b011;\n\tlocalparam VERIFY = 3'b100;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tdata <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (in == 0) state <= START;\n\t\t\t\tend\n\t\t\t\tSTART: begin\n\t\t\t\t\tstate <= DATA;\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\tend\n\t\t\t\tDATA: begin\n\t\t\t\t\tdata <= {in, data[7:1]};\n\t\t\t\t\tif (bit_count == 7) state <= STOP;\n\t\t\t\t\telse bit_count <= bit_count + 1;\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in == 1) state <= VERIFY;\n\t\t\t\t\telse state <= IDLE;\n\t\t\t\tend\n\t\t\t\tVERIFY: begin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\tend\n\t\t\t\tdefault: state <= IDLE;\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign done = (state == VERIFY);\n\nendmodule\n"}
{"task_id": "fsm_serialdata", "completion": "\treg [2:0] state;\n\treg [2:0] next_state;\n\treg [2:0] bit_count;\n\treg [7:0] shift_reg;\n\n\tlocalparam IDLE = 3'b000;\n\tlocalparam START = 3'b001;\n\tlocalparam DATA = 3'b010;\n\tlocalparam STOP = 3'b011;\n\tlocalparam WAIT = 3'b100;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tshift_reg <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == DATA) begin\n\t\t\t\tshift_reg <= {in, shift_reg[7:1]};\n\t\t\t\tbit_count <= bit_count + 1;\n\t\t\tend else if (state == IDLE) begin\n\t\t\t\tbit_count <= 0;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: next_state = (in == 0) ? START : IDLE;\n\t\t\tSTART: next_state = DATA;\n\t\t\tDATA: next_state = (bit_count == 7) ? STOP : DATA;\n\t\t\tSTOP: next_state = (in == 1) ? WAIT : IDLE;\n\t\t\tWAIT: next_state = (in == 1) ? IDLE : WAIT;\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\n\tassign out_byte = shift_reg;\n\tassign done = (state == STOP);\n\nendmodule\n"}
{"task_id": "gshare", "completion": "\twire [6:0] global_history;\n\twire [6:0] index;\n\twire [1:0] counter;\n\treg [1:0] counter_next;\n\n\t// Global branch history register\n\treg [6:0] global_history_reg;\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tglobal_history_reg <= 7'b0;\n\t\telse if (train_valid)\n\t\t\tglobal_history_reg <= {global_history_reg[5:0], train_taken};\n\tend\n\tassign global_history = global_history_reg;\n\n\t// Pattern history table (PHT)\n\treg [1:0] pht [127:0];\n\twire [6:0] pht_index = global_history ^ predict_pc;\n\n\t// Prediction logic\n\tassign predict_taken = pht[pht_index][1];\n\tassign predict_history = global_history;\n\n\t// Training logic\n\talways @(*) begin\n\t\tcase (pht[pht_index])\n\t\t\t2'b00: counter_next = train_taken ? 2'b01 : 2'b00;\n\t\t\t2'b01: counter_next = 2'b11;\n\t\t\t2'b11: counter_next = train_taken ? 2'b11 : 2'b01;\n\t\t\t2'b10: counter_next = train_taken ? 2'b11 : 2'b00;\n\t\tendcase\n\tend\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tfor (int i = 0; i < 128; i++)\n\t\t\t\tpht[i] <= 2'b01;\n\t\tend else if (train_valid) begin\n\t\t\tpht[pht_index] <= counter_next;\n\t\tend\n\tend\n\nendmodule\n"}
{"task_id": "lemmings4", "completion": "\t// State encoding\n\tlocalparam WALK_LEFT = 2'b00;\n\tlocalparam WALK_RIGHT = 2'b01;\n\tlocalparam FALL_LEFT = 2'b10;\n\tlocalparam FALL_RIGHT = 2'b11;\n\n\treg [1:0] state, next_state;\n\treg [4:0] fall_counter;\n\treg splatter;\n\n\t// State register\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= WALK_LEFT;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (bump_left)\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse if (!ground)\n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (bump_right)\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse if (!ground)\n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\tend\n\t\t\tFALL_LEFT: begin\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\tend\n\t\t\tFALL_RIGHT: begin\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\tend\n\t\tendcase\n\n\t\t// Splatter condition\n\t\tif (fall_counter == 5'd20 && ground)\n\t\t\tnext_state = WALK_LEFT;\n\tend\n\n\t// Output logic\n\tassign walk_left = (state == WALK_LEFT);\n\tassign walk_right = (state == WALK_RIGHT);\n\tassign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n\tassign digging = (state == WALK_LEFT || state == WALK_RIGHT) && dig && ground;\n\n\t// Fall counter logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tfall_counter <= 5'd0;\n\t\telse if (state == FALL_LEFT || state == FALL_RIGHT)\n\t\t\tfall_counter <= fall_counter + 1;\n\t\telse\n\t\t\tfall_counter <= 5'd0;\n\tend\n\n\t// Splatter logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tsplatter <= 1'b0;\n\t\telse if (fall_counter == 5'd20 && ground)\n\t\t\tsplatter <= 1'b1;\n\t\telse if (ground)\n\t\t\tsplatter <= 1'b0;\n\tend\n\nendmodule\n"}
{"task_id": "review2015_fsm", "completion": "    // State encoding\n    localparam IDLE = 3'b000;\n    localparam S1 = 3'b001;\n    localparam S2 = 3'b010;\n    localparam S3 = 3'b011;\n    localparam S4 = 3'b100;\n    localparam WAIT = 3'b101;\n    localparam DONE = 3'b110;\n\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (data == 1'b1)\n                    next_state = S1;\n            end\n            S1: begin\n                if (data == 1'b1)\n                    next_state = S2;\n                else\n                    next_state = IDLE;\n            end\n            S2: begin\n                if (data == 1'b1)\n                    next_state = S3;\n                else\n                    next_state = IDLE;\n            end\n            S3: begin\n                if (data == 1'b0)\n                    next_state = S4;\n                else\n                    next_state = IDLE;\n            end\n            S4: begin\n                shift_ena = 1'b1;\n                next_state = WAIT;\n            end\n            WAIT: begin\n                counting = 1'b1;\n                if (done_counting)\n                    next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n"}
{"task_id": "conwaylife", "completion": "\twire [255:0] next_q;\n\n\tgenvar i, j;\n\tgenerate\n\t\tfor (i = 0; i < 16; i = i + 1) begin : row\n\t\t\tfor (j = 0; j < 16; j = j + 1) begin : col\n\t\t\t\tgame_cell cell (\n\t\t\t\t\t.clk(clk),\n\t\t\t\t\t.load(load),\n\t\t\t\t\t.data(data[i*16+j]),\n\t\t\t\t\t.q(q[i*16+j]),\n\t\t\t\t\t.next_q(next_q[i*16+j])\n\t\t\t\t);\n\t\t\tend\n\t\tend\n\tendgenerate\n\n\talways @(posedge clk) begin\n\t\tq <= next_q;\n\tend\n\nendmodule\n\n\twire [3:0] neighbours;\n\tassign neighbours = q + q[(15-16):0] + q[(15-32):16] + q[(15-48):32] + q[(15-64):48] + q[(15-80):64] + q[(15-96):80] + q[(15-112):96] + q[(15-128):112];\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tnext_q <= data;\n\t\tend else begin\n\t\t\tcase (neighbours)\n\t\t\t\t4'd0, 4'd1: next_q <= 1'b0;\n\t\t\t\t4'd2: next_q <= q;\n\t\t\t\t4'd3: next_q <= 1'b1;\n\t\t\t\t4'd4, 4'd5, 4'd6, 4'd7, 4'd8, 4'd9, 4'd10, 4'd11, 4'd12, 4'd13, 4'd14, 4'd15: next_q <= 1'b0;\n\t\t\t\tdefault: next_q <= q;\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n"}
{"task_id": "lemmings3", "completion": "\t// State encoding\n\tlocalparam WALK_LEFT = 2'b00;\n\tlocalparam WALK_RIGHT = 2'b01;\n\tlocalparam FALL_LEFT = 2'b10;\n\tlocalparam FALL_RIGHT = 2'b11;\n\n\treg [1:0] state, next_state;\n\n\t// State register\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= WALK_LEFT;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\t\telse if (bump_left)\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\t\telse if (bump_right)\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\tend\n\t\t\tFALL_LEFT: begin\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\tend\n\t\t\tFALL_RIGHT: begin\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\tend\n\t\t\tdefault: next_state = WALK_LEFT;\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign walk_left = (state == WALK_LEFT);\n\tassign walk_right = (state == WALK_RIGHT);\n\tassign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\tassign digging = (state == WALK_LEFT && ground && dig) || (state == WALK_RIGHT && ground && dig);\n\nendmodule\n"}
{"task_id": "count_clock", "completion": "\treg [5:0] seconds;\n\treg [5:0] minutes;\n\treg [4:0] hours;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tseconds <= 0;\n\t\t\tminutes <= 0;\n\t\t\thours <= 12;\n\t\t\tpm <= 0;\n\t\tend\n\t\telse if (ena) begin\n\t\t\tif (seconds == 59) begin\n\t\t\t\tseconds <= 0;\n\t\t\t\tif (minutes == 59) begin\n\t\t\t\t\tminutes <= 0;\n\t\t\t\t\tif (hours == 12) begin\n\t\t\t\t\t\thours <= 1;\n\t\t\t\t\t\tpm <= ~pm;\n\t\t\t\t\tend\n\t\t\t\t\telse if (hours == 11) begin\n\t\t\t\t\t\thours <= 12;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\thours <= hours + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tminutes <= minutes + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tseconds <= seconds + 1;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\thh = {3'b0, hours};\n\t\tmm = {3'b0, minutes};\n\t\tss = {3'b0, seconds};\n\tend\n\nendmodule\n"}
{"task_id": "lemmings2", "completion": "\t// State encoding\n\tlocalparam WALK_LEFT = 2'b00;\n\tlocalparam WALK_RIGHT = 2'b01;\n\tlocalparam FALL_LEFT = 2'b10;\n\tlocalparam FALL_RIGHT = 2'b11;\n\n\treg [1:0] state, next_state;\n\n\t// State register\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= WALK_LEFT;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\t\telse if (bump_left)\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\t\telse if (bump_right)\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\tend\n\t\t\tFALL_LEFT: begin\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse if (bump_left)\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\tend\n\t\t\tFALL_RIGHT: begin\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse if (bump_right)\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\tend\n\t\t\tdefault: next_state = WALK_LEFT;\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign walk_left = (state == WALK_LEFT);\n\tassign walk_right = (state == WALK_RIGHT);\n\tassign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n\nendmodule\n"}
{"task_id": "countbcd", "completion": "\treg [3:0] ones, tens, hundreds, thousands;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tones <= 4'b0000;\n\t\t\ttens <= 4'b0000;\n\t\t\thundreds <= 4'b0000;\n\t\t\tthousands <= 4'b0000;\n\t\tend\n\t\telse begin\n\t\t\tif (ones == 4'b1001) begin\n\t\t\t\tones <= 4'b0000;\n\t\t\t\tif (tens == 4'b1001) begin\n\t\t\t\t\ttens <= 4'b0000;\n\t\t\t\t\tif (hundreds == 4'b1001) begin\n\t\t\t\t\t\thundreds <= 4'b0000;\n\t\t\t\t\t\tif (thousands == 4'b1001)\n\t\t\t\t\t\t\tthousands <= 4'b0000;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthousands <= thousands + 1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\thundreds <= hundreds + 1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\ttens <= tens + 1;\n\t\t\tend\n\t\t\telse\n\t\t\t\tones <= ones + 1;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tq = {thousands, hundreds, tens, ones};\n\t\tena[1] = (ones == 4'b1001) && (tens != 4'b1001);\n\t\tena[2] = ena[1] && (tens == 4'b1001) && (hundreds != 4'b1001);\n\t\tena[3] = ena[2] && (hundreds == 4'b1001) && (thousands != 4'b1001);\n\tend\n\nendmodule\n"}
